---
title: "HW3"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(ggplot2)
library(dplyr)

```

Plot QuarterUnitPizza distribution kernel

```{r}
# Define the function
curve <- function(x) {
  sqrt(1 - x^2)
}

# Create a sequence of x values from 0 to 1
x <- seq(0, 1, length.out = 100)

# Compute the corresponding y values
y <- curve(x)

# Plot the function
plot(x, y, type = "l", col = "purple", lwd = 2, 
     xlab = "x", ylab = "f(x)", 
     main = expression(sqrt(1 - x^2)))

```

```{r}

#creating bivariate sequences

y1 <- runif(100, min = 0, max = 1)
x1 <- runif(100, min = 0, max = 1)

# adding points to the function

plot(x, y, type = "l", col = "red", lwd = 2, 
     xlab = "x", ylab = "f(x)", 
     main = expression(sqrt(1 - x^2)))+
  points(x1, y1, col = "blue", pch = 19)

# add a box around this

```

```{r}
# sampling 10 random x variables from the runif section

# Set the number of samples
n <- 1000000

# Generate bivariate uniform samples
x2 <- runif(n, min = 0, max = 1)
y2 <- runif(n, min = 0, max = 1)

# Filter samples to satisfy x^2 + y^2 \leq 1
filtered_samples <- data.frame(x2, y2)[sqrt(x^2 + y^2) <= 1, ]

# Select random variables that can be used to create the hist
set.seed(123) # For reproducibility because random will change
selected_samples <- filtered_samples[sample(nrow(filtered_samples), 1000), ]

test <- filtered_samples %>% 
  filter(x2 <= (sqrt(x^2 + y^2 <=1)))

# Print the selected samples
print(selected_samples)

# Plot histogram of the filtered samples

# this should look curved like the unit circle, fix me
hist(filtered_samples$x2, breaks = 50, main = "Histogram of Filtered X Samples", xlab = "X values")
hist(filtered_samples$y2, breaks = 50, main = "Histogram of Filtered Y Samples", xlab = "Y values")


```

```{r}

# Assuming you have already filtered your samples
# PI is the number of points inside the quarter circle
# PG is the total number of points generated

estimate_pi_filtered <- function(PI, PG) {
  pi_estimate <- 4 * (PI / PG)
  return(pi_estimate)
}

# Defining the parameters for the loop
PI <- 910000  # Number of points inside the quarter circle
PG <- 1000000  # Total number of points generated
pi_estimate <- estimate_pi_filtered(PI, PG)
print(paste("Estimated value of Ï€:", pi_estimate))


```

```{r}
intfuns <- function(x){1-x^2^(1/2)(1/k)}
integrate((x)(intfuns, lower = 0, upper = 1))

#FIX ME

#should also be getting a number that's pi

```

```{r}

# FIXME

#integrate the function

EX <- integer(intfuns(x))

# (X \cdot (1-X^2)^2(1\k))  is the integral basically)


#this is for Var(x)
# mu should be the value u got from first integrate E(X-mu)^2, 

# values for the G section will be the filtered values from the unit circle. The values you get with mean and shit, the answer should be similar to the numbers you got in Question F

```
