---
title: "HW3"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(ggplot2)
```

Plot QuarterUnitPizza distribution kernel

```{r}
# Define the function
curve <- function(x) {
  sqrt(1 - x^2)
}

# Create a sequence of x values from 0 to 1
x <- seq(0, 1, length.out = 100)

# Compute the corresponding y values
y <- curve(x)

# Plot the function
plot(x, y, type = "l", col = "purple", lwd = 2, 
     xlab = "x", ylab = "f(x)", 
     main = expression(sqrt(1 - x^2)))

```


```{r}

#creating bivariate sequences

y1 <- runif(100, min = 0, max = 1)
x1 <- runif(100, min = 0, max = 1)

# adding points to the function

plot(x, y, type = "l", col = "red", lwd = 2, 
     xlab = "x", ylab = "f(x)", 
     main = expression(sqrt(1 - x^2)))+
  points(x1, y1, col = "blue", pch = 19)


```


```{r}
# sampling 10 random x variables from the runif section

# Set the number of samples
n <- 1000000

# Generate bivariate uniform samples
x2 <- runif(n, min = 0, max = 1)
y2 <- runif(n, min = 0, max = 1)

# Filter samples to satisfy x^2 + y^2 \leq 1
filtered_samples <- data.frame(x2, y2)[x^2 + y^2 <= 1, ]

# Select 10 random variables
set.seed(123) # For reproducibility because random will change
selected_samples <- filtered_samples[sample(nrow(filtered_samples), 10), ]

# Print the selected samples
print(selected_samples)

# Plot histogram of the filtered samples
hist(filtered_samples$x, breaks = 50, main = "Histogram of Filtered X Samples", xlab = "X values")
hist(filtered_samples$y, breaks = 50, main = "Histogram of Filtered Y Samples", xlab = "Y values")


```


```{r}

# Assuming you have already filtered your samples
# PI is the number of points inside the quarter circle
# PG is the total number of points generated

estimate_pi_filtered <- function(PI, PG) {
  pi_estimate <- 4 * (PI / PG)
  return(pi_estimate)
}

# Defining the parameters for the loop
PI <- 910000  # Number of points inside the quarter circle
PG <- 1000000  # Total number of points generated
pi_estimate <- estimate_pi_filtered(PI, PG)
print(paste("Estimated value of Ï€:", pi_estimate))


```


```{r}
intfuns <- function(x){x^2 + y^2}
integrate(intfuns, lower = 0, upper = 1)

#FIX ME

```

```{r}

# FIXME

#integrate the function

EX <- integer(intfuns(x))




```

